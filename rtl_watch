#! /usr/bin/env python3
#  rtl_watch
VERSION="3.0.0"

#  Python program for real-time monitoring of ISM packets.
#
#  Monitors mqtt packets from a computer running rtl_433 to
#  collect data from and analyze characteristics of ISM-band
#  remote-sensing device transmissions (433MHz in the US).
#
#  rtl_433 on the monitoring computer analyzes radio packets
#  and broadcasts the information in JSON format for
#  recognized packets via mqtt broker host
#
#  rtl_watch subscribes to that published mqtt stream to
#  record, count, and analyze signal strength and other date
#  for packets received by that RTL_SDR dongle.  rtl_watch can
#  run on the monitoring computer or any number of other computers
#  on the LAN to which the monitoring computer is connected.
#
#  Devices and analyzed data are displayed in real time in
#  a window on the computer running rtl_watch.
#  Analyzed data includes
#     Device Name, # of records seen, and
#        signal-to-noise ratio mean, standard deviation, min, and max;
#        signal frequency mean, standard deviation, min, and max;
#        time between packets mean, standard deviation, min, and max;
#        number of packets per transmission
#           mean, standard deviation, min, and max.
#  The data are updated dynamically, as the packets are seen.
#
#  At any time, user can print a summary of devices seen
#  to date, and then analysis continues.
#
#  Written by H. David Todd, hdtodd@gmail.com, 2023.03.02
#  V1.0.0 Initial working version, 2023.02
#  V2.0.0 modifications 2023.05: expanded set of characteristics,
#         improved window handling, improved parameter-setting
#  V3.0.0 modifications 2024.07: use a queue and threads to
#         catch and records all packets

import argparse
import sys
import os
import signal
from   paho.mqtt import client as mqtt_client
import random
import json
import time
import datetime
import math
from   enum import IntEnum
from queue import Queue
import threading
try:
    import tkinter as tk
    from tkinter import ttk
    import tkinter.font as tkFont
    import tkinter.messagebox
except ImportError:
    import Tkinter as tk
    import ttk
    import Tkinter.font as tkFont
    import Tkinter.messagebox

AP_DESCRIPTION="""
rtl_433_watch:  Real-time monitor for ISM-band device transmissions
                as observed and published via MQTT by rtl_433.
"""

AP_EPILOG="""

"""

###################################################################################
# A class to compute mean, standard deviation, min, and max of a stream  of numbers
class Stats():

   def __init__(self, x):
      self.count = 1      # Count of values included in this stat
      self.mean  = x      # Mean of those values
      self.std2  = 0.0    # *SQUARE* of standard deviation of the stream of values
      self.min   = x      # Minimum value observed in the stream
      self.max   = x      # Maximum value observed in the stream
      
   def append(self,x):
      self.count += 1
      self.mean   = ((self.count-1)*self.mean + x)/self.count
      self.std2   = 0 if self.count<2 else ( (self.count-2)*self.std2 +
                                             (self.count*(self.mean-x)**2)/(self.count-1) )/(self.count-1)
      self.min    = x if x<self.min else self.min
      self.max    = x if x>self.max else self.max
      return

   def get(self):
      return (self.count, self.mean, math.sqrt(self.std2), self.min, self.max)

##########################################################################################
# Define a class to hold the data for each device and procedures to create, update, access
# Data values include:
#    dev:  The identifier for this device
#    dRow: Row of the display table at which this device's data should be reported
#    snr:  Signal-to-noise ratio over all transmissions
#    ITGT: Inter-Transmission Gap Time (time between transmissions)
#    Freq: Radio frequency of the packets over all transmissions
#    PPT:  Packets per transmission
#    Battery status flag
#    Status flag that may be reported by the device
#    Warning level: highest level seen
#    Warning flag: character used to indicate the current warning level for the device
class Data:
    def __init__(self, dev, dRow, eTime, snr, freq, battery, status):
        self.dev           = dev     # This device's identifier
        self.dRow          = dRow    # Row of the display table where this device should show
        self.pktcount      = 1       # Number of packets from this device
        self.xmtcount      = 1       # Number of transmissions from this device
        self.pkt_xmt       = 1       # Number of packets in this transmission
        self.last_pkt_time = eTime   # Time stamp of last packet
        self.last_xmt_time = eTime   # Time stamp of last transmission
        self.battery       = battery # Battery flag of last transmission
        self.status        = status  # Status flag of last transmission
        self.SNR           = None if omitSNR  else Stats(snr)      # Holds stats for snr 
        self.ITGT          = None                                  # Holds stats for ITGT
        self.Freq          = None if omitFreq else Stats(freq)     # Holds stats for Freq
        self.PPT           = None                                  # Holds stats for PPT
        self.wlevel        = Warn.ALARM if battery==0 else Warn.OK # Records highest warning
        self.warn          = Warnings[self.wlevel]                 # Display flag for warning
        return

    # Update information about this device and return a
    #  flag to indicate if it was a duplicate record for this xmit
    def update(self, eTime, snr, freq, battery, status):
        self.pktcount += 1
        self.last_pkt_time = eTime
        dup = eTime < self.last_xmt_time + dup_thresh
        if not omitSNR:
            self.SNR.append(snr)
        if not omitITGT and not dup:
            if self.ITGT is None:
                self.ITGT = Stats(eTime-self.last_xmt_time)
            else:
                self.ITGT.append(eTime-self.last_xmt_time)
            self.last_xmt_time = eTime
            self.xmtcount += 1
            self.last_xmt_time = eTime
        if not omitFreq:
            self.Freq.append(freq)
        if not omitPPT:
            if not dup:
                if self.PPT is None:
                    self.PPT = Stats(self.pkt_xmt)
                else:
                    self.PPT.append(self.pkt_xmt)
                self.pkt_xmt = 0
            self.pkt_xmt += 1
        self.wlevel    = max(self.wlevel, Warn.ALARM if battery==0 else Warn.OK,
                             Warn.ALERT if status != self.status else Warn.OK)
        self.warn      = Warnings[self.wlevel]
        return dup

    def get(self):
        return (self.pktcount,
                self.xmtcount,
                self.SNR,
                self.ITGT,
                self.Freq,
                self.PPT)

###################################################################################
# Global variable initialization

# MQTT connection management
# Parameters used to establish the mqtt connection to the rtl_433
#   receiver mqtt publisher
host      = None
topic     = "rtl_433/+/events"
port      = 1883
username  = ""
password  = ""
client_id = f'python-mqtt-{random.randint(0, 100)}'

# Variables and constants used globally
win        = None
frm_table  = None
grp_cnt    = 0
tbl_width  = 0
fullscreen = False
collecting = True    
bfont      = None
dfont      = None
hfont      = None
lfont      = None
pktcnt     = 0
totrecs    = 0
first_rec  = True
noTPMS     = True
omitSNR    = False
omitITGT   = False
omitFreq   = False
omitPPT    = False
debug      = False
debugW     = False
CSIBLK     = "\033[30m"
CSIRED     = "\033[31m"
CSIYLW     = "\033[93m"
CSIMGN     = "\033[95m"
CSIBLU     = "\033[34m"
CSIGRN     = "\033[32m"
Warn_Sign  = "\U000026A0"
bl_flag    = "\U0000203C"  # '!!': want to use "\U0001FAAB" {low battery} but not available
st_flag    = "\U00002049"  # '?!'
Warnings   = [" ", st_flag, bl_flag]
Warn       = IntEnum('Warn', [ ('OK', 0), ('ALERT', 1), ('ALARM', 2)])

global exit_event
global msg_q

# Set 2-sec threshhold for rejecting duplicate records
dup_thresh = 2.0

##########################################################################################
# DoubleScrolledFrame class adapted from
#   https://gist.github.com/novel-yet-trivial/2841b7b640bba48928200ff979204115
class DoubleScrolledFrame:
    """
    A vertically scrolled Frame that can be treated like any other Frame
    ie it needs a master and layout and it can be a master.
    keyword arguments are passed to the underlying Frame
    except the keyword arguments 'width' and 'height', which
    are passed to the underlying Canvas
    note that a widget layed out in this frame will have Canvas as self.master,
    if you subclass this there is no built in way for the children to access it.
    You need to provide the controller separately.
    """
    def __init__(self, master, **kwargs):
        width = kwargs.pop('width', None)
        height = kwargs.pop('height', None)
        self.outer = tk.Frame(master, **kwargs)

        self.vsb = ttk.Scrollbar(self.outer, orient=tk.VERTICAL)
        self.vsb.grid(row=0, column=1, sticky='ns')
        self.hsb = ttk.Scrollbar(self.outer, orient=tk.HORIZONTAL)
        self.hsb.grid(row=1, column=0, sticky='ew')
        self.canvas = tk.Canvas(self.outer, highlightthickness=0, width=width, height=height)
        self.canvas.grid(row=0, column=0, sticky='nsew')
        self.outer.rowconfigure(0, weight=1)
        self.outer.columnconfigure(0, weight=1)
        self.canvas['yscrollcommand'] = self.vsb.set
        self.canvas['xscrollcommand'] = self.hsb.set
        # mouse scroll does not seem to work with just "bind"; You have
        # to use "bind_all". Therefore to use multiple windows you have
        # to bind_all in the current widget
        self.canvas.bind("<Enter>", self._bind_mouse)
        self.canvas.bind("<Leave>", self._unbind_mouse)
        self.vsb['command'] = self.canvas.yview
        self.hsb['command'] = self.canvas.xview

        self.inner = tk.Frame(self.canvas)
        # pack the inner Frame into the Canvas with the topleft corner 4 pixels offset
        self.canvas.create_window(4, 4, window=self.inner, anchor='nw')
        self.inner.bind("<Configure>", self._on_frame_configure)

        self.outer_attr = set(dir(tk.Widget))

    def __getattr__(self, item):
        if item in self.outer_attr:
            # geometry attributes etc (eg pack, destroy, tkraise) are passed on to self.outer
            return getattr(self.outer, item)
        else:
            # all other attributes (_w, children, etc) are passed to self.inner
            return getattr(self.inner, item)

    def _on_frame_configure(self, event=None):
        x1, y1, x2, y2 = self.canvas.bbox("all")
        height = self.canvas.winfo_height()
        width = self.canvas.winfo_width()
        self.canvas.config(scrollregion = (0,0, max(x2, width), max(y2, height)))

    def _bind_mouse(self, event=None):
        self.canvas.bind_all("<4>", self._on_mousewheel)
        self.canvas.bind_all("<5>", self._on_mousewheel)
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)

    def _unbind_mouse(self, event=None):
        self.canvas.unbind_all("<4>")
        self.canvas.unbind_all("<5>")
        self.canvas.unbind_all("<MouseWheel>")
        
    def _on_mousewheel(self, event):
        """Linux uses event.num; Windows / Mac uses event.delta"""
        func = self.canvas.xview_scroll if event.state & 1 else self.canvas.yview_scroll 
        if event.num == 4 or event.delta > 0:
            func(-1, "units" )
        elif event.num == 5 or event.delta < 0:
            func(1, "units" )
    
    def __str__(self):
        return str(self.outer)

###############################################################################
#  Create the command parser, parse cmd line,  and set defaults
def make_parser():

    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=AP_DESCRIPTION, epilog=AP_EPILOG)

    parser.add_argument("-H", "--host", dest="host", type=str,
                        default=host,
                        help="MQTT hostname to connect to (default: %(default)s)")
    parser.add_argument("-T", "--topic", dest="topic", type=str,
                        default=topic,
                        help="rtl_433 MQTT event topic to subscribe to (default: %(default)s)")
    parser.add_argument("-U", "--username", type=str, default=username,
                        help="MQTT username, if needed; defaults to blank")
    parser.add_argument("-P", "--password", type=str, default=password,
                        help="MQTT password, if needed; defaults to blank")
    parser.add_argument("-p", "--port", type=int, default=port,
                        help="MQTT port (default: %(default)s)")
    parser.add_argument("-x", "--exclude_noise", type=int, dest="noise",
                        help="Exclude device records with fewer than 'NOISE' packets seen")
    parser.add_argument("-w", "--xmt_window", dest="window", type=float,
                        help="Max time in sec for a packet group to be considered as one transmission (default: %(default)s)")
    parser.add_argument("-t", "--include_TPMS", action='store_true',
                        dest="include_TPMS", default=False, 
                        help="include tire pressure monitors in catalog (default: %(default)s)")
    parser.add_argument("-o", "--omit", choices=["SNR", "ITGT", "Freq", "PPT"],
                        nargs="+")
    parser.add_argument("-d", "--debug", dest="debug", action="store_true")
    parser.add_argument("-W", "--warn", dest="warn", action="store_true",
                        help="Inject warnings at pkts 20 & 40 to debug; requires -d")
    parser.add_argument("-v", "--version", action="version", version=VERSION)
    args = parser.parse_args()
    return args

###############################################################################
# Set execution parameters from cmdline
def set_params():
    global host, topic, username, password, port, debug, debugW
    global dup_thresh, tbl_width, grp_cnt
    global omitSNR, omitITGT, omitFreq, omitPPT
    
    args = make_parser()

    #  We need host and topic, so if not already provided by
    #    cmdline, env, or embedded source code, then ask for them
    if not args.host:
        if "MQTT_HOST" in os.environ:
            args.host = os.environ["MQTT_HOST"]
        else:
            if host is None:
                args.host = input("MQTT host name or IP: ")

    if not args.topic:
        if "MQTT_TOPIC" in os.environ:
            args.topic = os.environ["MQTT_TOPIC"]
        else:
            if topic is None:
                args.topic = input("MQTT topic: ")

    #  username and password may not be required, so don't prompt
    #    if not already provided; and port just defaults in parser
    if not args.username and 'MQTT_USERNAME' in os.environ:
        args.username = os.environ['MQTT_USERNAME']
    else:
        args.username = ""

    if not args.password and 'MQTT_PASSWORD' in os.environ:
        args.password = os.environ['MQTT_PASSWORD']
    else:
        args.password = ""

    if not args.port and 'MQTT_PORT' in os.environ:
        args.port = os.environ['MQTT_PORT']

    host     = args.host
    topic    = args.topic
    username = args.username
    password = args.password
    port     = args.port
    debug    = args.debug
    debugW   = args.debug and args.warn
    omitSNR  = args.omit is not None and "SNR"  in args.omit
    omitITGT = args.omit is not None and "ITGT" in args.omit
    omitFreq = args.omit is not None and "Freq" in args.omit
    omitPPT  = args.omit is not None and "PPT"  in args.omit
    noTPMS   = not args.include_TPMS
    if args.window is not None:
        dup_thresh = args.window
    grp_cnt  = 1 if not omitSNR  else 0;
    grp_cnt += 1 if not omitFreq else 0;
    grp_cnt += 1 if not omitITGT else 0;
    grp_cnt += 1 if not omitPPT  else 0;
    tbl_width = 4 + 2*grp_cnt

    if debug:
        print("Debug is ON")
        print("Parameter settings in execution are ...")
        print("\tMQTT host:    ", host)
        print("\tMQTT topic:   ", topic)
        print("\tMQTT username:", username)
        print("\tMQTT password:", password)
        print("\tMQTT port:    ", port)
        print("\tDebug warnings", debugW)
        print("\tIncluding" if not omitSNR  else "\tExcluding", "SNR Stats")
        print("\tIncluding" if not omitITGT else "\tExcluding", "ITGT Stats")
        print("\tIncluding" if not omitFreq else "\tExcluding", "Freq Stats")
        print("\tExcluding" if     noTPMS   else "\tIncluding", "TPMS devices")
        print("\tUsing transmission window of", dup_thresh)
        print("\tDisplay table width will be", tbl_width, "columns")
    return


###############################################################################
# Convert time from various formats to epoch time
def CnvTime(ts):
    if ts.find("-") > 0:
        try:
            eTime = datetime.datetime.fromisoformat(ts).timestamp()
        except ValueError as e:
            err={}
            print("datetime error in input line converting time string: ", ts)
            print("datetime  msg:", err.get("error", str(e)))
            sys.exit(1)
    else:
        try:
            eTime = float(ts)
        except ValueError as e:
            err = {}
            print("Datetime conversion failed on line with datetime string", ts)
            print("float() error msg:", err.get("error", str(e)))
            sys.exit(1)

    return(eTime)


###############################################################################
# Button action routines
def sortDevice():
    global collecting
    row = 1
    for	dev in sorted(devices):
        devices[dev].dRow = row
        write_display_row_for_device(dev)
        row += 1
    return

def sortRecCnt():
    global collecting
    cntlist = {}
    for dev in devices:
        (pkt,xmt,SNR,ITGT,Freq,PPT) = devices[dev].get()
        cnt = SNR.count
        key = f"{cnt:06}" + dev
        cntlist[key] = dev
    row = 1
    for rec in sorted(cntlist, reverse=True):
        devices[cntlist[rec]].dRow = row
        write_display_row_for_device(devices[cntlist[rec]].dev)
        row += 1
    return

def sortSnr():
    global collecting
    snrlist = {}
    for dev in devices:
        (pkt,xmt,SNR,ITGT,Freq,PPT) = devices[dev].get()
        snr = SNR.mean
        key = f"{snr:05.1f}" + dev
        snrlist[key] = dev
    row = 1
    for rec in sorted(snrlist, reverse=True):
        devices[snrlist[rec]].dRow = row
        write_display_row_for_device(devices[snrlist[rec]].dev)
        row += 1
    return

###############################################################################
# Reset device warnings to OK and rewrite the display table accordingly
def reset_warn():
    global collecting
    for dev in devices:
        devices[dev].battery = 1
        devices[dev].wlevel  = Warn.OK
        devices[dev].warn    = Warnings[Warn.OK]
    for row in range(1, len(tbl)):
        tbl[row][1].set(Warnings[Warn.OK])
    return

###############################################################################
# Pop up an info box with descriptions of the headings
def legend():
    explain = (
    "SNR: Signal-to-Noise Ratio of received radio signals\n\n"
    "Freq: Radio frequency of signal received\n\n"
    "ITGT: Inter-Transmission Gap Time (seconds between transmissions)\n\n"
    "PPT: Packets-Per-Transmission")

    tk.messagebox.showinfo(title="Headings Legend", message=explain)
    return

###############################################################################
# CNTL-C and QUIT button handler
def quit_prog():
    global exit_event
    global msg_q
    global mqtt
    global win
    print("Quitting from quit_prog")
    exit_event.set()
    msg_q.put(None)
    win.destroy()
    mqtt.loop_stop()
    mqtt.disconnect()


def toggle_collecting(event=None):
    global collecting
    if collecting:
        mqtt.loop_stop()
        time.sleep(.5)
        print("Data collection paused ...")
    else:
        mqtt.loop_start()
        print("Data collection resumed ...")
    collecting = not collecting
    return
    
def print_summary():
    global collecting
    global devices
    global dedups, totrecs
    global grp_cnt, omitSNR, omitFreq, omitITGT, omitPPT
    ruler = 48 + 18*grp_cnt
    with open("rtl-watch.prn", 'a') as f:
        print("\n{:<120}".format("-"*ruler), file=f)
        print("rtl_watch: Printing summary of recorded rtl_433 packets\n", file=f)
        print("Monitoring host", host, "topic", topic, file=f)
        print("First entry recorded at:", earliest_time.get(),
              "\tLast entry recorded at:", last_time.get(), file=f) 
        print("Processed", dedups, "de-duplicated transmissions of a total of", totrecs, "packets", file=f)

        print("\n{:>48}".format(" "), end="", file=f)
        if not omitSNR:
            print("{:>18} ".format("Signal-to-Noise"), end="", file=f)
        if not omitFreq:
            print("{:^18} ".format("  Frequency"), end="", file=f)
        if not omitITGT:
            print("{:^18} ".format("ITGT (sec)"), end="", file=f)
        if not omitPPT:
            print("{:^18}".format("PPT"), end="", file=f)
        print("\n{:>48}  ".format(" "), end="", file=f)
        if not omitSNR:
            print("{:>16}    ".format("-"*15), end="", file=f)
        if not omitFreq:
            print("{:^15}   ".format("-"*15), end="", file=f)
        if not omitITGT:
            print("{:^15}   ".format("-"*15), end="", file=f)
        if not omitPPT:
            print("{:^14}   ".format("-"*14), end="", file=f)
        print(file=f)
        print("{:<30} {:>8} {:>8}".format("Device", "Pkts", "Xmits"), end="", file=f)
        if not omitSNR:
            print("   {:>8} ±{:>5}".format("Mean", "𝜎  "), end="", file=f)
        if not omitFreq:
            print("   {:>8} ±{:>5}".format("Mean", "𝜎  "), end="", file=f)
        if not omitITGT:
            print("   {:>8} ±{:>5}".format("Mean", "𝜎  "), end="", file=f)
        if not omitPPT:
            print("   {:>8} ±{:>5}".format("Mean", "𝜎  "), end="", file=f)
        print(file=f)
        for dev in sorted(devices):
            (pkt,xmt,SNR,ITGT,Freq,PPT) = devices[dev].get()
            print("{:<30} {:>8d} {:>8d}".format(dev,pkt,xmt), end="", file=f)
            if not omitSNR:
                (n,avg,std,min,max) = SNR.get()
                print("   {:>8.1f} ±{:>5.2f}".format(avg,std), end="", file=f)
            if not omitFreq:
                (n,avg,std,min,max) = Freq.get()
                print("   {:>8.3f} ± {:>5.3f}".format(avg,std), end="", file=f)
            if not omitITGT and ITGT is not None:
                (n,avg,std,min,max) = ITGT.get()
                print("  {:>8.1f} ±{:>5.2f}".format(avg,std), end="", file=f)
            if not omitPPT and PPT is not None:
                (n,avg,std,min,max) = PPT.get()
                print("   {:>8.1f} ±{:>5.2f}".format(avg,std), end="", file=f)
            print(file=f)
        print("\n{:<120}".format("-"*ruler), file=f)
    print("rtl_433_watch summary table appended to file \'rtl-watch.prn'")
    return

###############################################################################
# Functions for displaying

# Write the row on the display for device "dev"
def write_display_row_for_device(dev):
    global devices, tbl
    global omitSNR, omitITGT, omitFreq, omitPPT
    dRow = devices[dev].dRow
    (pkt,xmt,SNR,ITGT,Freq,PPT) = devices[dev].get()
    (cnt,snr,sigma,min,max) = SNR.get()
    try:
        tbl[dRow][0].set(dev)
        tbl[dRow][1].set(devices[dev].warn)
        tbl[dRow][2].set(pkt)
        tbl[dRow][3].set(xmt)
        col = 4
        if not omitSNR:
            tbl[dRow][col].set(round(snr,1))
            tbl[dRow][col+1].set(round(sigma,2))
            col += 2
        if not omitFreq:
            (cnt,freq,sigma,min,max) = Freq.get()
            tbl[dRow][col].set(round(freq,3))
            tbl[dRow][col+1].set(round(sigma,3))
            col += 2
        if not omitITGT and ITGT is not None:
            (cnt,itgt,sigma,min,max) = ITGT.get()
            tbl[dRow][col].set(round(itgt,1))
            tbl[dRow][col+1].set(round(sigma,2))
            col += 2
        if not omitPPT and PPT is not None:
            (cnt,ppt,sigma,min,max) = PPT.get()
            tbl[dRow][col].set(round(ppt,1))
            tbl[dRow][col+1].set(round(sigma,2))
    except Exception as e:
        print("Exception when trying to set display values for row", dRow)
        print("Exception:", str(e))
    return
        
# Toggle fullscreen
def toggle_fullscreen(event=None):
    global win
    global fullscreen

    fullscreen = not fullscreen
    win.attributes('-fullscreen', fullscreen)
    resize()
    return

# Automatically resize font size based on window size
def resize(event=None):
    global bfont
    global dfont
    global lfont
    global hfont
    global win

    # Resize font based on frame height (minimum size of 12)
    # Use negative number for "pixels" instead of "points"
    hfont.configure(size=-max(36, int((win.winfo_height() / 18))))
    bfont.configure(size=-max(24, int((win.winfo_height() / 24))))
    dfont.configure(size=-max(24, int((win.winfo_height() / 24))))
    lfont.configure(size=-max(30, int((win.winfo_height() / 24))))

    return


###############################################################################
# MQTT functions and display updating
# Connect to  MQTT host
def connect_mqtt() -> mqtt_client:
    def on_connect(mqtt, userdata, flags, rc):
        if rc == 0:
            print("Connected to MQTT broker host!")
        else:
            print("Failed attempt to connect to ", mqtt)
            print("  with userdata ", userdata)
            print("Return code %d\n", rc)
            sys.exit(1)
        return #from on_connect
    
    # Work around paho-mqtt v1, v2+ Client instantiation parameter diffs
    try:
        mqtt = mqtt_client.Client(client_id, clean_session=False)
    except:
        mqtt = mqtt_client.Client(mqtt_client.CallbackAPIVersion.VERSION1, client_id, clean_session=False)
    mqtt.username_pw_set(username, password)
    mqtt.on_connect = on_connect
    mqtt.connect(host, port)
    return mqtt #from connect_mqtt()

# Process messages that are put into the queue by 'on_message'
def process_msg(mqtt):
    global exit_event
    global msg_q
    global first_rec, last_rec
    global devices
    global dedups, totrecs
    global tbl
    while True:
        msg = msg_q.get()
        if msg == None:
            mqtt.loop_stop()
            print("Stop mqtt loop in 'process_msg'")
            break
        else:
            # Parse the json payload and process
            # When we get a record, ignore if it's a duplicate,
            #   update display if it isn't
            y = json.loads(msg.payload.decode())

            # Is this a record type that we want to process?
            if "model" not in y:
                return
            if noTPMS and "type" in y and y["type"]=="TPMS":
                return

            #  Create the device identifier as "model/channel/id"
            dev = y["model"] + "/"
            if "channel" in y:
                dev += str(y["channel"])
            dev += "/"
            if "id" in y:
                dev += str(y["id"])

            # Convert data values to standard form
            eTime   = CnvTime(y["time"])
            snr     = 0.0 if "snr"  not in y else float(y['snr'])
            freq    = 0.0 if "freq" not in y else float(y["freq"])
            battery = None if "battery_ok" not in y else y["battery_ok"]
            status  = None if "status"     not in y else y["status"]

            print(dev, "\t", eTime)
            
            # if debuging warnings (-d -W), inject warning conditions at pkts 10, 20
            if debugW:
                if pktcnt==10:
                    status = 9
                    print(CSIMGN, "Inserting status-code change for display debugging", CSIBLK)
                if pktcnt==20:
                    battery = 0
                    print(CSIRED, "Inserting battery-low condition for display debugging", CSIBLK)

            if dev in devices:
                dup = devices[dev].update(eTime, snr, freq, battery, status)
            else:
                dRow = len(tbl)
                if debug:
                    print("Appending new device", dev, " to end of tbl at row", dRow)
                devices[dev] = Data(dev, dRow, eTime, snr, freq, battery, status)
                add_row(dRow)
                dup = False

            if not dup:
                dedups += 1
                if debug:
                    print("{:<25} {:<20} snr={:>4.1f}".format(dev, y["time"], snr) )

                if first_rec:
                    earliest_time.set( y["time"])
                    first_rec = False
                last_time.set(y["time"])
#[hdt]
            write_display_row_for_device(dev)

            pkt_cnt.set(totrecs)
            xmt_cnt.set(dedups)
            # No return; thread exits when loop_stop() is invoked

# Subscribe to rtl_433 publication & process records we receive
def subscribe(mqtt: mqtt_client):
    def on_message(mqtt, userdata, msg):
        global msg_q
        global totrecs
        
        # count this new record and queue it for processing
        totrecs += 1
        msg_q.put(msg)
        return
        
    mqtt.subscribe(topic)
    mqtt.on_message = on_message
    if debug:
        print("Subscribed to mqtt feed")
    mqtt.loop_start()
    return #From subscribe(), but 'on_message' is active

#######################################################################################
# Table management and display

# Add a row to the display table, "tbl", at current next-entry index and increment the index                         
# Format the widgets, and handle row 0 differently as it is the header                                               
# Widget values get filled in by "main" (for header) or "on_message" (for data values) 
def add_row(dRow):
    global frm_table, tbl, tbl_width
    global omitSNR, omitITGT, omitFreq, omitPPT
    
    tbl.append( tuple(tk.StringVar() for i in range(tbl_width) ) )
    row = tk.Frame(frm_table)
    # Color the header row differently                                                                               
    if dRow==0:
        (bg, fg, fbg, ffg) = ("cornflower blue", "white", "yellow", "black")
    else:
        (bg, fg, fbg, ffg) = ("white",           "black", "white",  "black")

    lbl_device = tk.Label(row, width=30, textvariable=tbl[dRow][0], font=dfont, bg=bg)
    lbl_flag   = tk.Label(row, width=1,  textvariable=tbl[dRow][1], font=dfont, bg=fbg, fg=ffg)
    lbl_pktcnt = tk.Label(row, width=10, textvariable=tbl[dRow][2], font=dfont, bg=bg)
    lbl_xmtcnt = tk.Label(row, width=10, textvariable=tbl[dRow][3], font=dfont, bg=bg)
    lbl_device.grid(row=dRow, column=0, padx=2, pady=2, sticky="W")
    lbl_flag.grid(  row=dRow, column=1, padx=2, pady=2, sticky="W")
    lbl_pktcnt.grid(row=dRow, column=2, padx=2, pady=2, sticky="W")
    lbl_xmtcnt.grid(row=dRow, column=3, padx=2, pady=2, sticky="W")
    col = 4
    if not omitSNR:
        lbl_snr    = tk.Label(row, width=10, textvariable=tbl[dRow][col],   font=dfont, bg=bg)
        lbl_snr𝜎   = tk.Label(row, width=10, textvariable=tbl[dRow][col+1], font=dfont, bg=bg)
        lbl_snr.grid( row=dRow, column=col,   padx=2, pady=2, sticky="W")
        lbl_snr𝜎.grid(row=dRow, column=col+1, padx=2, pady=2, sticky="W")
        col += 2
    if not omitFreq:
        lbl_freq    = tk.Label(row, width=10, textvariable=tbl[dRow][col],   font=dfont, bg=bg)
        lbl_freq𝜎   = tk.Label(row, width=10, textvariable=tbl[dRow][col+1], font=dfont, bg=bg)
        lbl_freq.grid( row=dRow, column=col,   padx=2, pady=2, sticky="W")
        lbl_freq𝜎.grid(row=dRow, column=col+1, padx=2, pady=2, sticky="W")
        col += 2
    if not omitITGT:
        lbl_itgt    = tk.Label(row, width=10, textvariable=tbl[dRow][col],   font=dfont, bg=bg)
        lbl_itgt𝜎   = tk.Label(row, width=10, textvariable=tbl[dRow][col+1], font=dfont, bg=bg)
        lbl_itgt.grid( row=dRow, column=col,   padx=2, pady=2, sticky="W")
        lbl_itgt𝜎.grid(row=dRow, column=col+1, padx=2, pady=2, sticky="W")
        col += 2
    if not omitPPT:
        lbl_ppt    = tk.Label(row, width=10, textvariable=tbl[dRow][col],   font=dfont, bg=bg)
        lbl_ppt𝜎   = tk.Label(row, width=10, textvariable=tbl[dRow][col+1], font=dfont, bg=bg)
        lbl_ppt.grid( row=dRow, column=col,   padx=2, pady=2, sticky="W")
        lbl_ppt𝜎.grid(row=dRow, column=col+1, padx=2, pady=2, sticky="W")
        col += 2

    row.pack(side="top")
    return


###############################################################################               
# Create the display panels and table section                                                 
def create_display():
    global win, frm_table, bfont, dfont, hfont, lfont
    global earliest_time, last_time, pkt_cnt, xmt_cnt
    global totrecs, dedups
    global omitSNR, omitITGT, omitFreq, omitPPT
    
    # Create the main window and dynamic fonts
    win = tk.Tk()
    win.title("rtl_watch")
    hfont = tkFont.Font(size=40)
    bfont = tkFont.Font(size=24)
    dfont = tkFont.Font(size=18)
    lfont = tkFont.Font(size=30, weight="bold")

    # Build the title section of the display
    frm_title = tk.Frame(win, borderwidth=10, relief="groove")
    frm_title.pack(side="top", fill="x", expand=False)
    lbl_title  = tk.Label(frm_title, text="rtl_watch: monitor ISM devices using rtl_433",
                          font=hfont, bg="medium sea green", fg="white")
    lbl_title.pack(anchor="center", fill="x")

    # Build the button menu
    frm_toolbar = tk.Frame(win)
    frm_toolbar.pack(side="top", fill="x", expand=False)
    btn_device  = tk.Button(frm_toolbar, text="Sort Device",   command=sortDevice,
                            relief="raised", font=bfont)
    btn_reccnt  = tk.Button(frm_toolbar, text="Sort Count",    command=sortRecCnt,
                            relief="raised", font=bfont)
    btn_snr     = tk.Button(frm_toolbar, text="Sort SNR",      command=sortSnr,
                            relief="raised", font=bfont)
    btn_quit    = tk.Button(frm_toolbar, text="Quit",          command=quit_prog,
                            relief="raised", font=bfont, fg="red")
    btn_toggle  = tk.Button(frm_toolbar, text="Togl",          command=toggle_fullscreen,
                            relief="raised", font=bfont, fg='blue')
    btn_prtsum  = tk.Button(frm_toolbar, text="Print Summary", command=print_summary,
                            relief="raised", font=bfont, fg="green")
    btn_wrst    = tk.Button(frm_toolbar, text="Reset Warn",    command=reset_warn,
                            relief="raised", font=bfont, fg='orange')
    btn_legend  = tk.Button(frm_toolbar, text="Heading Info",    command=legend,
                            relief="raised", font=bfont, fg='magenta')
    btn_device.pack(side="left")
    btn_reccnt.pack(side="left")
    btn_snr.pack(side="left")
    btn_quit.pack(side="right")
    btn_toggle.pack(side="right")
    btn_prtsum.pack(side="right")
    btn_wrst.pack(side="right")
    btn_legend.pack(side="right")

    # Build the information section
    frm_info = tk.Frame(win, borderwidth=5, relief="raised")
    frm_info.pack(side="top", fill="x", expand=False)
    earliest_time = tk.StringVar()
    earliest_time.set(t.strftime('%Y-%m-%d %H:%M:%S'))
    last_time = tk.StringVar()
    last_time.set(t.strftime('%Y-%m-%d %H:%M:%S'))
    pkt_cnt = tk.StringVar()
    pkt_cnt.set(totrecs)
    xmt_cnt = tk.StringVar()
    xmt_cnt.set(dedups)
    lbl_monitor = tk.Label(frm_info, text="Monitoring host: %s and topic: %s" % (host, topic), font=dfont)
    lbl_monitor.pack(side="top", padx=5, pady=5)
    lbl_pkt = tk.Label(frm_info, text="Total pkts received:", font=dfont)
    lbl_pkt.pack(side="left", padx=5, pady=5)
    lbl_pcnt = tk.Label(frm_info, textvariable=pkt_cnt, font=dfont)
    lbl_pcnt.pack(side="left", padx=5, pady=5)
    lbl_xmt = tk.Label(frm_info, text="Total xmits received:", font=dfont)
    lbl_xmt.pack(side="left", padx=5, pady=5)
    lbl_xcnt = tk.Label(frm_info, textvariable=xmt_cnt, font=dfont)
    lbl_xcnt.pack(side="left", padx=5, pady=5)
    lbl_ltime = tk.Label(frm_info, textvariable=last_time,     font=dfont)
    lbl_ltime.pack(side="right", padx=5, pady=5)
    lbl_last = tk.Label(frm_info, text="Latest record:",    font=dfont)
    lbl_last.pack(side="right", padx=5, pady=5)
    lbl_ftime = tk.Label(frm_info, textvariable=earliest_time, font=dfont)
    lbl_ftime.pack(side="right", padx=5, pady=5)
    lbl_first = tk.Label(frm_info, text="Earliest record:", font=dfont)
    lbl_first.pack(side="right", padx=5, pady=5)

    # And create the table for data display, column header first
    frm_table = DoubleScrolledFrame(win, width=1280, relief="groove")
    frm_table.pack(side="top", fill="both", expand=True, padx=5, pady=5)

    # And insert the header as the first row
    add_row(0)
    tbl[0][0].set("Device\nmodel/channel/id")
    tbl[0][1].set(Warn_Sign)
    tbl[0][2].set("Pkt\nCount")
    tbl[0][3].set("Xmit\nCount")
    col = 4
    if not omitSNR:
        tbl[0][col].set("SNR\nMean")
        tbl[0][col+1].set("SNR\n𝜎")
        col += 2
    if not omitFreq:
        tbl[0][col].set("Freq\nMean")
        tbl[0][col+1].set("Freq\n𝜎")
        col += 2
    if not omitITGT:
        tbl[0][col].set("ITGT\nMean")
        tbl[0][col+1].set("ITGT\n𝜎")
        col += 2
    if not omitPPT:
        tbl[0][col].set("PPT\nMean")
        tbl[0][col+1].set("PPT\n𝜎")

    win.bind('<Escape>', toggle_fullscreen)
    if debug:
        win.bind('s', toggle_collecting)
    return

#######################################################################################
#  Main script

if __name__ == "__main__":

    global msg
    global userdata
    userdata = None
    exit_event = threading.Event()
    msg_q = Queue(0)
    t = datetime.datetime.now()
    signal.signal(signal.SIGINT, quit_prog)

    # Get command-line and enviroment parameters and set program variables
    set_params()

    # Initialize the Device:Data dictionary
    devices = {}

    # Init the list of widget rows to display
    tbl = []
    
    # Init the performance counters
    totrecs = 0
    dedups  = 0

    # Create the display
    create_display()

    # Connect to the mqtt host and subscribe to the feed.
    # This activates the on_message procedure in which
    #   MQTT events cause the displayed values to be updated
    mqtt = connect_mqtt()

    if debug:
        print("Entering main run loops")

    t1 = threading.Thread(target = process_msg, args=(mqtt,))
    t2 = threading.Thread(target = subscribe, args=(mqtt,))
    t1.start()
    t2.start()
    # Start the tkinter main loop and let MQTT events populate the display

    # Subscribe returns immediately but 'on_message' continues
    #   to respond to incoming 'msg' packets
    t2.join()
    print("'subscribe' thread exited but 'on_message' continues")

    # Start window; will be terminated by 'quit_prog'
    win.mainloop()

    t1.join()
    # Consumer thread, 'process_msg' has stopped: exit
    print("'process_msg' thread terminated; exiting normally")
    sys.exit(0)
